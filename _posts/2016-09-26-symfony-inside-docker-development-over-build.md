---
layout: post
title: "Symfony внутри Docker (разработка при помощи пересборки образа контейнера)"
---
Подход, рассматриваемый с данной статье, подразумевает что у вас есть так называемый "базовый Docker-образ" приложения, который должен содержать в себе всё необходимое ПО для функционирования приложения за исключением самого кода приложения. Сам код приложения будет располагаться в директории `/app`, так что сама директория `/app` должна существовать в "базовом образе", но должна быть пуста. Также подразумевается чтобы вы знакомы с такой утилитой как `docker-compose`.

## Начнём с docker-compose.yml

Ожидается что файлы `docker-compose.yml` и `Dockerfile` будут располагаться в корне Symfony-проекта. Возьмём для примера следующий `docker-compose.yml`:

    version: '2'
    services:
        db:
            image: postgres:9.5
            environment:
                POSTGRES_PASSWORD: megapassword
                POSTGRES_USER: app_user
                POSTGRES_DB: app_db
        app:
            build:
                context: .
                dockerfile: Dockerfile
            environment:
                POSTGRES_PASSWORD: megapassword
                POSTGRES_USER: app_user
                POSTGRES_DB: app_db
            links:
                - db
            ports:
                - "8080:80"

Основное внимание мы уделим следующим строчкам:

            build:
                context: .
                dockerfile: Dockerfile

Благодаря данным строчкам, при каждом выполнении `docker-compose up` будет выполняться сборка нового образа из которого потом будет запускаться контейнер с Symfony-приложением.

Файл `Dockerfile` имеет следующее содержимое:

    FROM myregistry.mycompany.com/app-base:v1
    COPY . /app

Для сборки образа с Symfony-приложением используется базовый образ, который расположен в Docker Registry `myregistry.mycompany.com/app-base:v1` (тему базового образа я постараюсь осветить в отдельной статье). И единственное действие, которое делается при сборке конечного образа, это копирование содержимого директории с проектом в директорию `/app` в Docker-образе.

После сборки образа должен получиться образ, на основе которого можно запустить Docker-контейнер с приложением.

Ещё в корень проекта можно добавить файл `.dockerignore`, куда можно прописать директории и файлы которые не должны попасть в образ контейнера. Например это поддиректории директории `var`. Файл `.dockerignore` может выглядеть следующим образом:

    var/*
    Dockerfile

Исключение поддиректорий директории `var` помогает ускорить сборку образа, так как в контекст сборки не попадают кэш и логи, которые никак не пригодятся при выполнении приложения в контейнере, так как при старте контейнера приложение всё равно должно прогревать свой кэш, а логи по идеологии Docker'а должны выводиться на стандартный выход, а не в файл. Ну о логах будет более подробнее в другой статье.

## Сборка и пересборка образа

Имея выше перечисленное можно выполнить команду `docker-compose up` и подождать несколько секунд пока текущее состояние вашей директории с кодом будет помещено в образ и на основе этого образа будет запущен Docker-контейнер с приложением. После этого можно открыть приложение по адресу http://localhost:8080/ и увидеть результат.

Стоит обратить внимание на то, что при изменении кода в директории с кодом проекта, изменения не попадут автоматически в запущенный контейнер. Если вы захотите увидеть результат своих правок в коде, то вам придётся проделать следующие действия в консоли:

    docker-compose stop # останавливаем запущение контейнеры
    docker-compose build app # пересобираем образ с новыми изменениями
    docker-compose rm -f app # удаляем контейнер со старым кодом приложения
    docker-compose up # стартуем все контейнеры

Данный способ плох тем, что после каждого изменения кода требуется пересобирать образ и стартовать новый контейнер, что занимает не мало времени. Но плюсом является большая близость к реальному процессу деплоя приложения на сервер, а также бОльшая универсальность, так как данный способ также больше подходит для проектов, разрабатываемых на компилируемых языках программирования (при изменении кода, в отличии от PHP, та же программа на C потребует перекомпиляции и перезапуска процесса программы, чтобы можно было увидеть уже новое поведение приложения).

Для разработки кода всяческих фоновых процессов я предпочитаю использовать именно этот вариант. При разработке кода фоновых процессов не требуется часто пересоздавать образ контейнера, так как временный интервалы между потребностями взглянуть на результат гораздо больше, чем при разработке frontend-части проекта, где любая правка требует нажатия кнопки F5 в браузере, чтобы увидеть результат изменения кода (это моё личное мнение как бэкэндера).

На этом всё. В следующих статьях я постараюсь осветить темы, которые по тексту выше обещал осветить. Также постараюсь написать серию статей на тему "Symfony-приложение как 12-факторное приложение".